# abc140

https://atcoder.jp/contests/abc140/submissions/me

## D

- 定義の単純化すると連続したものをいくつ作れるか
- 操作の意味をいろいろ試して理解する

## E

- 境界に番兵を入れることで実装を簡潔にする
- 和の取り替え
- bisectでインデックスの探索は速いが、listのinsertでO(n)だからダメだと思っていたら行けてしまった
- python ではordered dictという順列を保持するものがあるらしい

## F

- heapqでゴリ押した
- 要素の追加、削除がO(logn), 最小値の参照がO(1)でできるので、要素の書き換えがO(n)とかならいけるなあ
- 毎時刻、すでにできているスライムからまだ作られていないスライムに対し、できるだけ大きいものから作るのが最適
  - 尺取チックにやっていけば良い、高々n回、generatedとrestから要素を取り出し見比べ、条件を満たせばrestの方からgeneratedに追加する。満たさなければ次の時刻に用いるためにrestに追加し直す。time stepは18なので高々N*18.全体でO(nlogn)
- 公式解説
  - 葉がスライムの値で親ノードは子ノードの最大値をとる二分木を考える.子同士の値が一致しないような葉の配置ができるかという問題に言い換え
